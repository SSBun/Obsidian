{
	"nodes":[
		{"id":"38a11f0f41d32a88","type":"file","file":"Resource/2112a03d-cc48-4db5-9740-94adc1a7efbf_2360x2920.png","x":-927,"y":-569,"width":920,"height":1138},
		{
			"id":"7f1b3350e0601f8c",
			"type":"text",
			"text":"**OAuth 2.0**（Open Authorization）是一个关于**授权（Authorization）**的开放网络标准。它允许用户让第三方应用在不告知账号密码的情况下，获得对用户存储在特定服务商上的信息的限制访问权限。\n\n简单来说，OAuth 的核心是**“令牌（Token）机制”**，即用令牌代替用户名和密码。\n\n---\n\n### 1. 核心类比：酒店房卡\n为了理解 OAuth，最经典的例子是**酒店房卡**：\n*   **用户名/密码（传统方式）：** 你把房间钥匙直接交给别人。拿到钥匙的人可以打开你的房门，甚至可以翻看你的保险箱，且你无法限制他的权限。\n*   **OAuth 方式（房卡）：** 你去前台（授权服务器）登记，前台给你一张房卡（Access Token）。\n    *   这张卡只能开特定的房间门（Scope 权限范围）。\n    *   这张卡有有效期（Expiration）。\n    *   你不需要把自己的身份证号和密码告诉别人，只需要给他们这张卡。\n\n---\n\n### 2. OAuth 的四个角色\n在 OAuth 流程中，通常涉及以下四个角色：\n1.  **资源所有者 (Resource Owner)：** 即“用户”。拥有数据的人。\n2.  **客户端 (Client)：** 想要访问用户数据的第三方应用（如：某个使用“微信登录”的游戏）。\n3.  **授权服务器 (Authorization Server)：** 验证用户身份并颁发令牌的服务商（如：微信的认证系统）。\n4.  **资源服务器 (Resource Server)：** 存放用户数据的服务器（如：微信的用户头像、好友列表 API）。\n\n---\n\n### 3. 授权码模式 (Authorization Code) 流程图\n这是 OAuth 2.0 中最常用、最安全的流程。\n\n```mermaid\ngraph TD\n    User[\"用户 (Resource Owner)\"]\n    Client[\"第三方应用 (Client)\"]\n    AuthServer[\"授权服务器 (Auth Server)\"]\n    ResServer[\"资源服务器 (Resource Server)\"]\n\n    User -- \"1.点击'使用GitHub登录'\" --> Client\n    Client -- \"2.重定向到GitHub授权页\" --> AuthServer\n    AuthServer -- \"3.询问用户是否同意授权\" --> User\n    User -- \"4.同意授权\" --> AuthServer\n    AuthServer -- \"5.返回授权码 (Code)\" --> Client\n    Client -- \"6.发送 Code + AppSecret\" --> AuthServer\n    AuthServer -- \"7.颁发访问令牌 (Access Token)\" --> Client\n    Client -- \"8.携带 Token 请求数据\" --> ResServer\n    ResServer -- \"9.返回用户头像/昵称\" --> Client\n```\n\n---\n\n### 4. 为什么需要 OAuth？（解决的问题）\n在 OAuth 出现之前，如果你想让一个打印服务打印你在 Google Drive 里的照片，你必须把 Google 账号和密码告诉打印服务。这存在巨大的安全隐患：\n*   **过度授权：** 打印服务拿到了密码，不仅能打印照片，还能删你的邮件。\n*   **密码泄露：** 如果打印服务被黑，你的 Google 密码就丢了。\n*   **无法撤销：** 你想让打印服务失效，必须改密码，这会导致所有依赖 Google 账号的服务都受影响。\n\n**OAuth 的优势：**\n*   **权限受限：** 令牌可以只授予“只读照片”的权限。\n*   **随时撤销：** 你可以在 Google 设置里单独取消对该打印服务的授权，而不影响密码。\n*   **无须共享密码：** 第三方应用永远接触不到用户的真实密码。\n\n---\n\n### 5. 常见误区：OAuth vs OpenID Connect (OIDC)\n*   **OAuth 2.0 是为了“授权” (Authorization)**：它回答的是“我能进入这间屋子吗？”\n*   **OIDC 是为了“认证” (Authentication)**：它基于 OAuth 2.0，回答的是“我是谁？”。\n    *   当你看到“使用 Google 账号登录”时，背后通常是 OIDC 协议，它在 OAuth 的基础上增加了一个 `ID Token` 来证明用户的身份。\n\n### 总结\nOAuth 协议是现代互联网的基石之一，它通过**令牌**实现了安全、受控的资源共享，让我们在享受第三方服务便利的同时，保护了核心账号的安全。",
			"styleAttributes":{},
			"x":200,
			"y":-1160,
			"width":800,
			"height":400,
			"color":"2"
		},
		{
			"id":"20b73c85e8baf9f2",
			"type":"text",
			"text":"## 为什么不在重定向授权页面的时候，直接携带 AppSecret， 然后由授权服务其直接返回AccessToken呢？而是要这面走两边来获取\n\n这是一个非常经典且深入的问题。你所描述的“直接返回 AccessToken”的方式其实在 OAuth 协议中确实存在，叫做**“隐式模式”（Implicit Grant）**，但由于安全风险，**目前该模式已被官方废弃**。\n\n之所以要多绕一圈（先拿授权码 Code，再换 Token），核心原因在于：**浏览器（前端）是不安全的。**\n\n以下是为什么要分两步走的详细原因：\n\n### 1. 防止 AppSecret 泄露\n**AppSecret 是第三方应用的“命根子”**，绝对不能暴露给用户或出现在浏览器端。\n*   **如果你在重定向时携带 AppSecret：** 这个密钥就会出现在浏览器的 URL 地址栏、浏览器历史记录以及互联网路由器的日志中。一旦泄露，黑客就可以伪造你的应用身份，去骗取其他用户的授权。\n*   **标准流程：** AppSecret 只在“后端服务器对服务器”的通信中传递（即第 6 步）。这一步不经过浏览器，是在内网或加密的 HTTPS 通道中完成的，极难被截获。\n\n---\n\n### 2. 防止 AccessToken 泄露（前端通道 vs 后端通道）\nOAuth 将通信路径分为两种：\n*   **前端通道 (Front-channel)：** 通过浏览器重定向。数据暴露在 URL 中，容易被拦截、记录或通过 `Referer` 头部泄露。\n*   **后端通道 (Back-channel)：** 两个服务器之间直接通信。数据不经过浏览器，安全性极高。\n\n**如果直接返回 AccessToken：**\nToken 会出现在浏览器的 URL 中（例如 `callback#access_token=xxx`）。如果用户浏览器安装了恶意插件，或者用户点击了某个链接导致 `Referer` 泄露，Token 就会被窃取。\n\n**通过授权码 (Code) 交换：**\n1.  **Code 是临时的、一次性的：** 即使 Code 在 URL 中被黑客截获，黑客也没有 `AppSecret`，无法用这个 Code 换取真正的 Token。\n2.  **Token 只在后端传递：** 真正的 AccessToken 是在服务器之间传递的，浏览器根本看不见它。\n\n---\n\n### 3. 身份校验的双重保障\n在第二步（用 Code 换 Token）时，授权服务器会校验两件事：\n1.  **Code 是否有效：** 证明用户确实点击了同意。\n2.  **AppSecret 是否匹配：** 证明发起请求的确实是那个合法的第三方应用服务器。\n\n这种“双因子”校验确保了：**即使黑客伪造了用户的授权，他也无法伪造应用的身份。**\n\n---\n\n### 4. 流程对比图\n\n为了更直观，我们对比一下**你建议的方案（不安全）**和**标准方案（安全）**：\n\n#### 你建议的方案（类似已废弃的隐式模式）\n```mermaid\nsequenceDiagram\n    participant User as \"用户浏览器 (不安全)\"\n    participant Client as \"第三方应用服务器\"\n    participant Auth as \"授权服务器\"\n\n    User->>Auth: 1.请求授权 (携带 AppSecret ❌ 危险)\n    Auth-->>User: 2.重定向返回 AccessToken (暴露在URL ❌ 危险)\n    User->>Client: 3.将 Token 传给应用后端\n```\n\n#### 标准授权码模式 (Authorization Code)\n```mermaid\nsequenceDiagram\n    participant Browser as \"用户浏览器 (不安全通道)\"\n    participant Client as \"第三方应用后端 (安全通道)\"\n    participant Auth as \"授权服务器\"\n\n    Note over Browser, Auth: 【前端通道】\n    Browser->>Auth: 1.请求授权 (仅携带 ClientID)\n    Auth-->>Browser: 2.返回授权码 Code (临时、一次性)\n    \n    Note over Client, Auth: 【后端通道 - 绝对安全】\n    Browser->>Client: 3.将 Code 传给后端\n    Client->>Auth: 4.发送 Code + AppSecret (验证身份)\n    Auth-->>Client: 5.返回 AccessToken\n```\n\n### 总结\n**“多绕一圈”是为了实现“前后端分离”的安全策略：**\n*   **前端（浏览器）**只负责跑腿，传递一个没啥大用的临时编号（Code）。\n*   **后端（服务器）**才负责拿着编号和“通关文牒”（AppSecret）去换取真正的钥匙（Token）。\n\n这样即使“跑腿的”被劫持了，黑客拿到的也只是一张没用的废纸，而真正的钥匙始终在安全的服务器之间传递。",
			"styleAttributes":{},
			"x":1120,
			"y":-1160,
			"width":800,
			"height":400,
			"color":"2"
		},
		{
			"id":"7340021d7b0ef1d2",
			"type":"text",
			"text":"**OpenID Connect (简称 OIDC)** 是建立在 **OAuth 2.0** 协议之上的一个**身份层（Identity Layer）**。\n\n如果说 OAuth 2.0 是为了解决“授权”问题（你能做什么），那么 OIDC 就是为了解决“认证”问题（你是谁）。\n\n---\n\n### 1. 核心类比：房卡 vs 身份证\n延续之前酒店的例子：\n*   **OAuth 2.0 (房卡)：** 酒店给你一张房卡，它能开门，但房卡上没有你的名字，门锁也不关心你是谁，只关心这张卡有没有开门的权限。\n*   **OIDC (身份证/护照)：** 在给你房卡的同时，前台还给了你一张“身份卡”。上面印着你的姓名、照片、出生日期。这张卡证明了**你的身份**。\n\n**为什么需要 OIDC？**\n原本 OAuth 2.0 并不提供用户信息，它只给一个令牌（Token）。很多开发者为了获取用户信息，不得不自己写 API（比如 `/me` 接口）。因为每个公司的接口定义都不一样（有的叫 `uid`，有的叫 `user_id`），导致兼容性很差。OIDC 的出现就是为了**标准化**这种身份认证。\n\n---\n\n### 2. OIDC 的核心公式\n> **OIDC = OAuth 2.0 + ID Token + UserInfo 接口**\n\nOIDC 在 OAuth 2.0 的基础上增加了几个关键元素：\n1.  **ID Token (身份令牌)：** 一个加密的字符串（通常是 **JWT** 格式），里面包含了用户的基本信息（如 ID、姓名、邮箱等）。\n2.  **特定的 Scope (权限范围)：** 客户端在请求时必须包含 `openid` 这个关键词。\n3.  **UserInfo Endpoint：** 一个标准化的接口，客户端拿着 Token 去请求，一定能返回统一格式的用户信息。\n\n---\n\n### 3. OIDC 的工作流程\n它的流程与 OAuth 2.0 的授权码模式几乎完全一样，唯一的区别是返回的内容。\n\n```mermaid\nsequenceDiagram\n    participant User as \"用户\"\n    participant Client as \"第三方应用\"\n    participant OIDC_Provider as \"认证中心 (如 Google/微信)\"\n\n    User->>Client: 1.点击 \"使用 Google 登录\"\n    Client->>OIDC_Provider: 2.跳转授权页 (Scope 包含 \"openid profile\")\n    User->>OIDC_Provider: 3.输入账号密码并同意\n    OIDC_Provider-->>Client: 4.返回授权码 (Code)\n    \n    Note over Client, OIDC_Provider: 后端交换\n    Client->>OIDC_Provider: 5.发送 Code + AppSecret\n    OIDC_Provider-->>Client: 6.返回 Access Token + ID Token (JWT)\n    \n    Note right of Client: Client 解析 ID Token 即可知道用户是谁\n```\n\n---\n\n### 4. 关键产物：ID Token (JWT)\n这是 OIDC 最核心的改进。ID Token 是一个 **JWT (JSON Web Token)**，它通常包含以下信息：\n*   **iss (Issuer):** 谁签发的（比如 `https://accounts.google.com`）。\n*   **sub (Subject):** 用户的唯一标识（用户 ID）。\n*   **aud (Audience):** 这个令牌是给哪个应用用的。\n*   **exp (Expiration):** 过期时间。\n*   **iat (Issued At):** 签发时间。\n\n**优点：** 第三方应用后端拿到 ID Token 后，**不需要**再去调用 API，直接解密这个字符串就能知道用户是谁，效率极高。\n\n---\n\n### 5. OAuth 2.0 vs OIDC 的区别\n\n| 特性 | OAuth 2.0 | OpenID Connect (OIDC) |\n| :--- | :--- | :--- |\n| **主要目的** | **授权** (Authorization) | **认证** (Authentication) |\n| **关注点** | 允许应用访问资源（如发微博、读文件） | 确认“当前登录的用户是谁” |\n| **产物** | **Access Token** (通常是不可读的字符串) | **ID Token** (JWT 格式，包含用户信息) |\n| **典型场景** | API 调用、第三方插件 | 单点登录 (SSO)、用户注册登录 |\n| **类比** | 酒店房卡 | 身份证 + 酒店房卡 |\n\n---\n\n### 6. 总结\n*   如果你只需要让一个应用代表用户去**操作数据**（比如同步相册），用 **OAuth 2.0**。\n*   如果你是想让用户**直接登录**你的系统，并获取他的**个人资料**，你应该使用 **OIDC**。\n\n现在市面上绝大多数的“社交登录”（Google, Microsoft, Apple, 微信）底层运行的其实都是 **OIDC** 协议。",
			"styleAttributes":{},
			"x":200,
			"y":-700,
			"width":800,
			"height":400,
			"color":"2"
		},
		{
			"id":"117fa4e6dc24dfa5",
			"type":"text",
			"text":"**SMB (Server Message Block)** 协议是一种**网络文件共享协议**，主要用于在计算机之间共享文件、打印机、串行端口以及进行命名管道（IPC）通信。\n\n它是 Windows 网络环境的核心，你平时在 Windows “网上邻居”里访问另一台电脑的文件夹，或者连接公司局域网的共享打印机，背后运行的几乎都是 SMB 协议。\n\n---\n\n### 1. 核心功能：它能做什么？\nSMB 协议的设计初衷是让程序能够像访问本地磁盘一样，通过网络访问远程计算机上的资源：\n*   **文件访问：** 打开、读取、写入、删除远程服务器上的文件。\n*   **打印机共享：** 将打印任务发送到网络上的共享打印机。\n*   **资源锁定：** 防止两个用户同时修改同一个文件（并发控制）。\n*   **进程间通信 (IPC)：** 允许不同计算机上的程序互相传递消息。\n\n---\n\n### 2. 发展历史与版本（非常重要）\nSMB 经历了多次重大演进，了解版本对于网络安全至关重要：\n\n*   **SMB 1.0 (1980年代):** 由 IBM 开发，后被微软采用。它非常臃肿、效率低下且**极不安全**。\n    *   *注：* 臭名昭著的 **WannaCry（永恒之蓝）** 勒索病毒就是利用了 SMB 1.0 的漏洞。\n*   **CIFS (Common Internet File System):** 微软在 90 年代对 SMB 1.0 的一个变体，曾试图将其推广为互联网标准，但现在已过时。\n*   **SMB 2.0 / 2.1 (Windows Vista / 7):** 重大改进。减少了“往返”次数（Chattiness），大幅提升了在宽带网络上的性能。\n*   **SMB 3.0 / 3.0.2 (Windows 8 / 8.1):** 引入了**端到端加密**、多通道（Multi-channel）提速和集群支持。\n*   **SMB 3.1.1 (Windows 10 / 11):** 目前最新的版本，增加了更强的预认证完整性校验和加密算法。\n\n---\n\n### 3. SMB 的工作原理\nSMB 采用典型的**客户端-服务器（Client-Server）**架构。\n\n```mermaid\nsequenceDiagram\n    participant Client as \"客户端 (你的电脑)\"\n    participant Server as \"服务器 (NAS/文件服务器)\"\n\n    Client->>Server: 1. 协商 (Negotiate) - \"你会哪个版本的 SMB？\"\n    Server-->>Client: 2. 回应 - \"我会 SMB 3.1.1\"\n    Client->>Server: 3. 建立会话 (Session Setup) - 提交用户名/密码\n    Server-->>Client: 4. 确认身份 - \"允许访问\"\n    Client->>Server: 5. 树连接 (Tree Connect) - \"我要访问 \\\\Server\\SharedFolder\"\n    Server-->>Client: 6. 确认路径 - \"连接成功\"\n    Client->>Server: 7. 操作请求 - \"读取 test.txt\"\n    Server-->>Client: 8. 返回数据 - [文件内容]\n```\n\n---\n\n### 4. 关键技术细节\n*   **端口：** 现代 SMB（2.0 及以上）统一使用 **TCP 445 端口**。早期的 SMB 还需要配合 NetBIOS 使用 137、139 端口。\n*   **认证机制：** 通常使用 NTLM 或 **Kerberos**（在 Windows 域环境下）进行身份验证。\n*   **方言 (Dialects)：** 客户端和服务器在连接初期会协商“方言”，以确保双方使用最高版本的共同协议。\n\n---\n\n### 5. SMB vs. NFS\n在文件共享领域，SMB 经常被拿来与 **NFS (Network File System)** 比较：\n*   **SMB：** 主要用于 **Windows** 环境。支持完善的用户权限管理（ACL），功能丰富，但协议相对复杂。\n*   **NFS：** 主要用于 **Linux/Unix** 环境。设计更简洁，在 Linux 集群间传输效率通常更高，但在 Windows 上的兼容性不如 SMB。\n\n---\n\n### 6. 安全建议（避坑指南）\n由于 SMB 经常成为黑客攻击的目标，建议遵循以下原则：\n1.  **禁用 SMB 1.0：** 它是现代网络最大的安全隐患之一，所有现代系统都应将其关闭。\n2.  **不要在公网暴露 445 端口：** 永远不要把 SMB 接口直接暴露在互联网上。如果需要远程访问，请使用 VPN。\n3.  **强制签名与加密：** 在 SMB 3.0+ 环境中开启加密，防止数据在传输过程中被窃听。\n4.  **使用强密码：** SMB 很容易受到暴力破解攻击。\n\n### 总结\nSMB 是局域网内文件传输的“老大哥”。它从一个简陋的共享协议演变成了今天支持加密、高性能、高可靠性的企业级文件系统协议。对于普通用户来说，它就是那个让你在电脑上轻松打开 NAS 电影或公司共享文档的幕后英雄。",
			"styleAttributes":{},
			"x":200,
			"y":-240,
			"width":800,
			"height":400
		},
		{
			"id":"0f922c3d00d04c4f",
			"type":"text",
			"text":"# MQTT 协议技术详解与 QoS 机制深度分析\n\n本文档整合了关于 MQTT 协议的定义、核心架构、服务质量（QoS）实现原理以及在极端网络和硬件故障下的容错机制。\n\n---\n\n## 1. 协议概述与核心理念\n\n**MQTT (Message Queuing Telemetry Transport)** 是一种基于 TCP/IP 协议栈构建的轻量级、发布/订阅（Publish/Subscribe）模式的通讯协议。\n\n### 1.1 设计目标\n该协议专门为以下环境设计：\n*   **受限设备：** 硬件性能低下、内存少、功耗敏感的远程设备（如传感器、嵌入式芯片）。\n*   **恶劣网络：** 低带宽、高延迟、网络连接不可靠（频繁断开）的环境。\n\n### 1.2 核心优势\n*   **极低开销：** 协议头部最小仅需 2 字节，最大程度节省流量。\n*   **解耦机制：** 发送者与接收者无需建立直接连接，也无需同时在线。\n*   **灵活性：** 支持多种服务质量等级，适应不同业务需求。\n\n---\n\n## 2. 核心架构：发布/订阅模式\n\nMQTT 摒弃了传统的 HTTP \"请求-响应\" 模式，采用 \"发布/订阅\" 模式。\n\n### 2.1 角色定义\n1.  **发布者 (Publisher)：** 数据的生产者（如：温度传感器）。\n2.  **代理 (Broker)：** 核心服务器，负责接收消息、维护订阅关系、分发消息（如：EMQX, Mosquitto）。\n3.  **订阅者 (Subscriber)：** 数据的消费者（如：手机 App, 后端数据库）。\n\n### 2.2 关键概念\n*   **主题 (Topic)：** 消息的路由标签（类似于文件路径，如 `home/livingroom/temp`）。\n    *   **单层通配符 `+`：** `home/+/temp` 匹配 `home/kitchen/temp`。\n    *   **多层通配符 `#`：** `home/#` 匹配 `home` 下所有层级。\n*   **保留消息 (Retained Message)：** Broker 保存该主题的最后一条消息，新订阅者上线即刻收到。\n*   **遗嘱消息 (LWT)：** 客户端非正常断线时，Broker 自动代发的告警消息。\n\n### 2.3 架构示意图\n\n```mermaid\ngraph LR\n    subgraph Publisher_Group [\"发布者 (Publishers)\"]\n        Sensor1[\"温度传感器\"]\n        Sensor2[\"GPS定位器\"]\n    end\n\n    subgraph Server_Side [\"服务端\"]\n        Broker[\"MQTT Broker (代理服务器)\"]\n    end\n\n    subgraph Subscriber_Group [\"订阅者 (Subscribers)\"]\n        Phone[\"手机 App\"]\n        DB[\"后端数据库\"]\n    end\n\n    Sensor1 -- \"发布: home/temp\" --> Broker\n    Sensor2 -- \"发布: car/gps\" --> Broker\n    Broker -- \"推送: home/temp\" --> Phone\n    Broker -- \"推送: car/gps\" --> DB\n```\n\n---\n\n## 3. QoS 服务质量等级详解\n\nMQTT 通过 **报文交互流程** 和 **Packet ID（报文标识符）** 实现三种不同等级的可靠性传输。\n\n### 3.1 QoS 0：最多一次 (At most once)\n*   **机制：** \"发后即忘\" (Fire and Forget)。\n*   **流程：** 发送端发送 `PUBLISH`，不等待确认，不重试。\n*   **适用：** 高频且允许丢失的数据（如实时路况、传感器高频采样）。\n\n### 3.2 QoS 1：至少一次 (At least once)\n*   **机制：** 保证送达，但可能重复。\n*   **流程：**\n    1.  发送端发送 `PUBLISH` (带 Packet ID)，本地保存副本。\n    2.  接收端收到后，回复 `PUBACK`。\n    3.  发送端收到 `PUBACK` 后删除副本。\n*   **重传：** 若超时未收到 `PUBACK`，发送端重发消息（标记 DUP=1）。\n*   **重复原因：** 若 `PUBACK` 丢失，发送端重发，接收端会再次收到并处理同一条消息。\n\n### 3.3 QoS 2：只有一次 (Exactly once)\n*   **机制：** 保证准确送达且不重复，使用四次握手。\n*   **适用：** 金融交易、计费、关键指令。\n\n#### QoS 2 四次握手流程图\n\n```mermaid\nsequenceDiagram\n    participant Sender as \"发送端\"\n    participant Receiver as \"接收端\"\n    \n    Note over Sender, Receiver: Phase 1: 传输与锁定\n    Sender->>Receiver: \"PUBLISH (QoS=2, ID=200)\"\n    Receiver->>Sender: \"PUBREC (ID=200)\"\n    Note right of Receiver: 缓存ID，暂不分发消息\n    \n    Note over Sender, Receiver: Phase 2: 释放与确认\n    Sender->>Receiver: \"PUBREL (ID=200)\"\n    Note left of Sender: 收到PUBREC，确认对方已收\n    \n    Receiver->>Sender: \"PUBCOMP (ID=200)\"\n    Note right of Receiver: 分发消息，删除ID缓存\n    Note left of Sender: 流程结束\n```\n\n---\n\n## 4. QoS 2 深度容错机制与边缘场景\n\n在 QoS 2 协议中，针对网络丢包和硬件故障有严格的处理逻辑。\n\n### 4.1 场景一：PUBCOMP 报文丢失\n**问题：** 接收端已处理完消息并发送 `PUBCOMP`，但该确认报文在网络中丢失。\n**处理流程：**\n1.  **发送端超时：** 发送端处于 \"Wait for Complete\" 状态，因收不到确认，触发超时重传机制，**重发 `PUBREL`** (注意：不是重发 `PUBLISH`)。\n2.  **接收端幂等处理：**\n    *   接收端收到重发的 `PUBREL`。\n    *   检查内部状态，发现该 ID 对应的消息已处理完毕。\n    *   **不进行业务处理**（防止重复消费）。\n    *   **直接重发 `PUBCOMP`**。\n3.  **结果：** 发送端最终收到确认，流程闭环。\n\n### 4.2 场景二：接收端断电/崩溃 (内存数据丢失)\n**问题：** 接收端在回复 `PUBREC` 后断电，内存清空。重启后收到发送端重发的 `PUBREL`。\n**后果分析：**\n*   **不会重复处理：** `PUBREL` 报文仅包含 Packet ID，**不包含消息体 (Payload)**。\n*   **数据丢失风险：**\n    *   如果接收端仅使用内存（RAM）存储：重启后内存清空，收到 `PUBREL` 时查不到对应数据，无法恢复消息内容，导致**消息丢失**。\n    *   接收端通常会回复 `PUBCOMP` 以结束错误的流程，但业务层收不到数据。\n\n---\n\n## 5. 持久化与会话管理 (Persistence & Sessions)\n\n为了解决上述断电导致的数据丢失问题，必须配合持久化存储和会话配置。\n\n### 5.1 存储策略\n要实现真正的 QoS 2 (抗断电)，接收端必须遵循以下 IO 顺序：\n1.  收到 `PUBLISH`。\n2.  **写入非易失性存储 (Disk/Flash)**：保存 Packet ID 和 Payload。\n3.  发送 `PUBREC`。\n4.  (断电重启后) 从磁盘加载未完成的流程。\n5.  收到 `PUBREL`，从磁盘读取 Payload 进行分发，然后删除磁盘记录。\n\n### 5.2 Clean Session (清理会话)\n*   **Clean Session = true (临时会话)：** 客户端断开连接后，Broker 和客户端会丢弃所有未完成的消息和订阅信息。**断电必丢数据。**\n*   **Clean Session = false (持久会话)：** 客户端断开后，双方保留状态。重连后，自动恢复未完成的 QoS 1/2 流程。\n\n### 5.3 总结对比表\n\n| 特性 | QoS 0 | QoS 1 | QoS 2 |\n| :--- | :--- | :--- | :--- |\n| **保证语义** | 最多一次 | 至少一次 | 只有一次 |\n| **报文往返** | 0 次 | 1 次 (2包) | 2 次 (4包) |\n| **接收端去重** | 无 | 需业务层处理 | **协议层自动去重** |\n| **断电后果(无持久化)** | 丢失 | 丢失 | **丢失 (不会重复)** |\n| **断电后果(有持久化)** | 丢失 | 恢复并重发 | **完美恢复** |",
			"styleAttributes":{},
			"x":200,
			"y":240,
			"width":800,
			"height":400
		}
	],
	"edges":[
		{
			"id":"93197c28a2f352fd",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"38a11f0f41d32a88",
			"fromSide":"right",
			"toNode":"7f1b3350e0601f8c",
			"toSide":"left"
		},
		{
			"id":"9b28bf6fd77d3609",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"7f1b3350e0601f8c",
			"fromSide":"right",
			"toNode":"20b73c85e8baf9f2",
			"toSide":"left"
		},
		{
			"id":"ae64b8e3d4203de2",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"38a11f0f41d32a88",
			"fromSide":"right",
			"toNode":"7340021d7b0ef1d2",
			"toSide":"left"
		},
		{
			"id":"436cb975fc37e7dc",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"38a11f0f41d32a88",
			"fromSide":"right",
			"toNode":"117fa4e6dc24dfa5",
			"toSide":"left"
		},
		{
			"id":"dbf00893b4979c78",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"38a11f0f41d32a88",
			"fromSide":"right",
			"toNode":"0f922c3d00d04c4f",
			"toSide":"left"
		}
	],
	"metadata":{
		"version":"1.0-1.0",
		"frontmatter":{}
	}
}