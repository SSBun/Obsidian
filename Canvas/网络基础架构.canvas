{
	"nodes":[
		{"id":"c38718bfa297e09c","type":"file","file":"什么是 SYN 消息？.md","x":940,"y":-1060,"width":670,"height":260},
		{"id":"b6bb4b9dfcd00acd","type":"file","file":"TCP “全双工”和“基于字节流”.md","x":940,"y":-1420,"width":670,"height":300},
		{"id":"d00e8a1bef0cefb6","type":"file","file":"Docs/TLS 握手过程完整详解.md","x":-1540,"y":-1420,"width":692,"height":380},
		{"id":"3d196d0cfa64859c","type":"text","text":"互联网基本架构","x":-1120,"y":80,"width":180,"height":50},
		{"id":"3e5ae91a55a88bd2","type":"text","text":"1. **1. 应用层 (Application Layer)**\n    - **主要协议**：\n        - **HTTP/HTTPS (超文本传输协议/安全超文本传输协议)**：用于Web浏览器和Web服务器之间传输网页内容。\n        - **FTP (文件传输协议)**：用于在客户端和服务器之间传输文件。\n        - **SMTP (简单邮件传输协议)**：用于发送电子邮件。\n        - **POP3/IMAP (邮局协议3/互联网消息访问协议)**：用于接收电子邮件。\n        - **DNS (域名系统)**：将域名（如www.example.com）解析为IP地址。\n    - **协议作用**：直接为用户应用程序提供网络服务，处理特定应用程序的数据格式和通信逻辑。\n    - **通俗举例**：你打开浏览器访问一个网站（HTTP），或者发送一封电子邮件（SMTP），或者下载一个文件（FTP）。DNS就像是互联网的电话簿，你输入一个网站名字，它帮你找到对应的“电话号码”（IP地址）。","x":-660,"y":-930,"width":692,"height":380},
		{"id":"8ab9973a1783d912","type":"text","text":"1. **2. 传输层 (Transport Layer)**\n    \n    - **主要协议**：\n        - **TCP (传输控制协议)**：提供可靠的、面向连接的数据传输服务。它确保数据按顺序、无差错地到达目的地。\n        - **UDP (用户数据报协议)**：提供不可靠的、无连接的数据传输服务。它不保证数据包的顺序或送达，但传输速度快。\n    - **协议作用**：负责端到端（即从一台计算机上的某个应用程序到另一台计算机上的某个应用程序）的数据传输。它处理数据的分段、重组、错误检测和流量控制。\n    - **通俗举例**：\n        - **TCP** 就像你寄送一个非常重要的包裹，需要签收、确认无误，并且如果中途丢失了会重新寄送。例如，你下载文件或发送邮件时，需要确保数据完整无误。\n        - **UDP** 就像你打电话或看直播，声音或画面可能会偶尔卡顿或丢失一两帧，但你更关心实时性，而不是每个字或每帧都完美无缺。","x":-660,"y":-490,"width":692,"height":380,"color":"6"},
		{"id":"a0635267dee089ee","type":"text","text":"1. **3. 网络层 (Network Layer)**\n    \n    - **主要协议**：\n        - **IP (互联网协议)**：负责数据包的寻址和路由，将数据包从源主机发送到目的主机。\n        - **ICMP (互联网控制消息协议)**：用于在网络设备之间传递错误消息和操作信息（如Ping命令）。\n    - **协议作用**：负责将数据包从一个网络传输到另一个网络，实现全球范围内的互连。它决定数据包的最佳路径。\n    - **通俗举例**：IP就像是邮政系统中的地址和路由功能。你的包裹（数据包）上有一个目的地址（IP地址），邮局（路由器）根据这个地址决定包裹应该走哪条路才能到达目的地。ICMP就像是邮局之间的内部沟通，比如“这个地址不存在”或者“这条路不通”。","x":-660,"y":-50,"width":692,"height":360,"color":"5"},
		{"id":"518713a596b3cbff","type":"text","text":"1. **4. 数据链路层 (Data Link Layer)**\n    \n    - **主要协议**：\n        - **Ethernet (以太网)**：最常见的有线局域网技术。\n        - **Wi-Fi (无线局域网)**：无线网络技术标准。\n        - **ARP (地址解析协议)**：将IP地址解析为物理MAC地址。\n    - **协议作用**：负责在直接相连的两个节点之间传输数据帧。它处理物理寻址（MAC地址）、错误检测和访问控制。\n    - **通俗举例**：这就像是你的小区内部的快递员。包裹（数据帧）已经到了你所在的城市（网络层），现在需要快递员（数据链路层）根据你家的具体门牌号（MAC地址）把包裹送到你手上。ARP就像是快递员查询你家门牌号对应的具体位置。","x":-660,"y":380,"width":692,"height":320,"color":"2"},
		{"id":"82e2829fe918b467","type":"text","text":"1. **5. 物理层 (Physical Layer)**\n    \n    - **主要协议**：没有特定的“协议”，更多是标准和规范。\n        - **各种物理介质标准**：如网线（双绞线、光纤）、无线电波等。\n        - **接口标准**：如RJ45接口、USB接口等。\n    - **协议作用**：负责传输原始的比特流（0和1）。它定义了物理接口的电气特性、机械特性、功能特性和过程特性，确保比特流能在物理介质上传输。\n    - **通俗举例**：这就像是实际的道路、电线、光缆或无线电波。它只负责把0和1的电信号或光信号从一个地方传到另一个地方，不关心这些信号代表什么信息。","x":-660,"y":800,"width":692,"height":240},
		{"id":"b9bdb30c217fe544","type":"text","text":"### TTL (Time To Live - 生存时间) 概述\n\n**TTL**，全称 **Time To Live**，直译为“生存时间”。它是一个在网络通信中非常重要的机制，主要用于**限制数据包或数据记录在网络中存在的有效时间或跳数**。其核心目的是防止数据无限期地在网络中循环，以及控制缓存数据的有效性。\n\nTTL主要在两个不同的上下文中发挥作用：\n\n#### 1. IP数据包中的TTL\n\n*   **作用**：在IP数据包的头部有一个TTL字段（8位整数）。它的主要目的是**防止数据包在网络中无限循环**，从而耗尽网络资源。\n*   **工作原理**：\n    1.  当一个IP数据包被发送时，发送方会给它的TTL字段设置一个初始值（通常是64或128）。\n    2.  每当数据包经过一个路由器（即“跳”到下一个网络设备）时，路由器会将数据包的TTL值减1。\n    3.  如果TTL值减到0，路由器就会丢弃这个数据包，并通常会向源主机发送一个ICMP“时间超时”错误消息。\n*   **通俗举例**：想象你寄送一个包裹，上面写着“最多经过10个中转站”。每经过一个中转站，工作人员就会在上面划掉一个数字。如果包裹经过了10个中转站还没到达目的地，第11个中转站就会把包裹丢弃，并通知你包裹超时了。这确保了包裹不会永远在中转站之间打转。\n*   **实际应用**：`ping` 和 `traceroute` (或 `tracert`) 命令就是利用TTL机制来诊断网络连通性和路径的。`traceroute` 通过发送不同TTL值的探测包来确定数据包经过的每个路由器。\n\n#### 2. DNS记录中的TTL\n\n*   **作用**：在DNS（域名系统）记录中，TTL字段指示了**DNS解析器（如ISP的DNS服务器或本地计算机）应该缓存该DNS记录多长时间**。\n*   **工作原理**：\n    1.  当一个DNS解析器查询到一个域名的IP地址时，它会同时获取到该记录的TTL值。\n    2.  解析器会根据这个TTL值将该记录缓存起来。在TTL过期之前，所有对该域名的后续查询都会直接从缓存中获取结果，而无需再次向权威DNS服务器查询。\n    3.  当TTL过期后，解析器会认为缓存的记录已失效，下次查询时会重新向权威DNS服务器发起请求，以获取最新的记录。\n*   **通俗举例**：你第一次查询一个网站的电话号码（IP地址）时，电话簿（DNS服务器）告诉你这个号码，并说“这个号码在接下来的1小时内是有效的”。你就会把这个号码记在你的小本本上，并且在1小时内，每次想打这个网站电话时，都直接查小本本。1小时后，你就会认为小本本上的号码可能已经过期了，下次需要时会重新查电话簿。\n*   **实际应用**：\n    *   **高TTL值**：意味着DNS记录更新后，需要更长时间才能在全球范围内生效，但可以减少DNS服务器的负载和查询延迟。\n    *   **低TTL值**：意味着DNS记录更新后，可以更快地在全球范围内生效，这对于需要频繁更改IP地址（如负载均衡、故障切换）的服务非常有用，但会增加DNS服务器的负载。\n\n#### 总结\n\n无论是IP数据包还是DNS记录，TTL的核心思想都是**设置一个有效期**。对于IP数据包，它是一个“跳数限制”，防止数据包迷失；对于DNS记录，它是一个“缓存有效期”，控制数据新鲜度和查询效率。理解TTL对于网络故障排查、DNS管理和网络性能优化都至关重要。","x":-130,"y":1320,"width":890,"height":380},
		{"id":"2ee1d7063c316a59","type":"text","text":"## 常见网络解析的TTL设计对比\n\n| 特性         | IP数据包 TTL (Time To Live)                               | DNS记录 TTL (Time To Live)                               | ARP缓存 TTL (Time To Live)                               |\n| :----------- | :-------------------------------------------------------- | :------------------------------------------------------- | :------------------------------------------------------- |\n| **应用层级** | 网络层 (IP协议头部)                                     | 应用层 (DNS记录)                                         | 数据链路层 (ARP协议缓存)                                 |\n| **目的**     | **防止数据包在网络中无限循环**，耗尽网络资源。          | **控制DNS记录的缓存时间**，平衡查询效率与数据新鲜度。   | **平衡ARP解析效率与MAC地址映射的准确性**，减少ARP广播。 |\n| **计量单位** | **跳数 (Hop Count)**                                      | **秒 (Seconds)**                                         | **秒 (Seconds)**                                         |\n| **典型值**   | 初始值通常为 **64, 128, 255**。                           | **几分钟到几天** (例如：300秒, 3600秒, 86400秒)。        | **几十秒到几分钟** (例如：30秒, 120秒, 300秒)。          |\n| **工作机制** | 每经过一个路由器，TTL值减1。当TTL减到0时，数据包被丢弃。 | DNS解析器缓存记录，并在TTL过期后重新查询权威DNS服务器。 | ARP条目在缓存中存在，TTL递减。过期后条目被删除，需重新ARP解析。 |\n| **TTL过高影响** | 数据包可能在路由环路中长时间循环，浪费网络带宽。        | DNS记录更新后，全球生效时间长，用户可能访问到旧资源。   | 缓存条目长时间不更新，可能使用过时的MAC地址，导致通信失败。 |\n| **TTL过低影响** | 数据包可能在到达目的地前就被丢弃（如果跳数过多）。      | 增加DNS服务器负载，增加DNS查询延迟，降低缓存命中率。    | 频繁进行ARP请求，增加网络上的ARP广播流量和解析延迟。   |\n| **可配置性** | 初始值通常由操作系统或应用程序设置，用户一般不直接修改。 | 由域名所有者或DNS服务提供商配置。                       | 通常由操作系统或网络设备默认设置，但管理员可手动调整。   |\n| **刷新机制** | 无（一旦设置，只递减）。                                | 无（过期即失效，需重新查询）。                           | 部分系统会在条目过期前再次使用时刷新其TTL。              |","x":-130,"y":1780,"width":890,"height":394},
		{"id":"932d4850b6ed05ec","type":"text","text":"## TTL的类型\n你观察得很对，TTL（Time To Live）在IP数据包、DNS记录和ARP缓存中确实都是一个数值，通过跳数或秒数递减来表示其“生存时间”。这是最常见和标准的设计。\n\n然而，如果我们将“TTL”的概念更广义地理解为**“有效生命周期”或“过期机制”**，那么在网络和分布式系统中，确实存在其他设计方案和使用方法来管理数据的生命周期，而不仅仅是简单的递减计数器。这些方案通常在更高的协议层或应用层实现。\n\n以下是一些“TTL”概念的扩展设计和使用方法：\n\n1.  **绝对过期时间 (Timestamp-based Expiration)**\n    *   **设计方案**：不是一个递减的计数器，而是一个**固定的未来时间戳**（例如，Unix时间戳），表示数据或凭证何时失效。\n    *   **使用方法**：系统只需将当前时间与该时间戳进行比较。如果当前时间超过了时间戳，则数据过期。\n    *   **通俗举例**：\n        *   **安全令牌 (JWT)**：JSON Web Token（JWT）中通常包含一个 `exp` (expiration time) 字段，它是一个具体的日期时间，表示令牌何时失效。\n        *   **会话管理**：用户登录后的会话可能有一个固定的过期时间，无论用户是否活跃，到点即失效。\n    *   **对比传统TTL**：传统TTL是“还能活多久”，而绝对过期时间是“活到什么时候”。\n\n2.  **使用次数限制 (Usage Count / Max Uses)**\n    *   **设计方案**：数据或凭证不是基于时间或跳数过期，而是基于**被访问或使用的次数**。\n    *   **使用方法**：每次使用时，一个内部计数器递减。当计数器达到零时，数据或凭证失效。\n    *   **通俗举例**：\n        *   **一次性密码 (OTP)**：某些验证码或密码只允许使用一次。\n        *   **临时API密钥**：一个API密钥可能被设计为只能调用某个API 100次，之后就失效。\n    *   **对比传统TTL**：传统TTL是“还能活多久”，而使用次数限制是“还能用几次”。\n\n3.  **事件驱动过期 (Event-Driven Expiration)**\n    *   **设计方案**：数据的生命周期与特定的**网络事件或应用事件**绑定。当某个预设事件发生时，数据立即失效。\n    *   **使用方法**：系统监听特定事件。事件触发时，相关数据被标记为过期或删除。\n    *   **通俗举例**：\n        *   **TCP连接状态**：一个TCP连接的状态（如ESTABLISHED）在收到FIN或RST包时会立即改变并最终关闭，而不是等待一个固定的时间。\n        *   **防火墙会话**：防火墙可能会跟踪网络连接，当检测到连接的正常关闭（如TCP FIN/RST）时，会话状态立即过期，而不是等待一个固定的超时时间。\n        *   **缓存失效**：当底层数据源发生变化时，相关缓存项立即失效，而不是等待其时间TTL过期。\n    *   **对比传统TTL**：传统TTL是“时间到了就过期”，而事件驱动是“事情发生了就过期”。\n\n4.  **自适应/动态TTL (Adaptive/Dynamic TTL)**\n    *   **设计方案**：TTL的值不是固定的，而是根据**网络条件、数据稳定性、访问模式或其他动态因素**自动调整。\n    *   **使用方法**：一个算法或策略会根据实时监测的数据来计算或调整TTL值。\n    *   **通俗举例**：\n        *   **动态DNS服务**：某些高级DNS服务可能会根据IP地址的变动频率来动态调整DNS记录的TTL。如果IP地址经常变动，TTL会设置得较短，以确保快速更新；如果IP地址稳定，TTL会设置得较长。\n        *   **路由协议计时器**：在某些路由协议中，路由信息的“老化时间”或“保持时间”可能会根据网络的稳定性或链路状态动态调整，以防止路由震荡或快速收敛。\n    *   **对比传统TTL**：传统TTL是“固定活多久”，而自适应TTL是“根据情况决定活多久”。\n\n这些“TTL”的变体在不同的网络和系统设计中都扮演着关键角色，它们共同构成了管理数据和状态生命周期的强大工具集。虽然核心概念都是“有效期”，但实现方式和触发机制可以非常多样化。","x":860,"y":1780,"width":671,"height":463},
		{"id":"1b7efd5a34e7ccb0","type":"text","text":"### 以太网 (Ethernet) 简介\n\n以太网是一种局域网（LAN）技术，它是目前最广泛使用的有线网络技术，用于连接家庭、办公室、数据中心等环境中的计算机和其他网络设备。它定义了数据链路层和物理层的标准，规定了数据如何在物理介质（如网线或光纤）上传输、如何寻址以及如何控制对共享介质的访问。\n\n#### 1. 历史与标准化\n\n*   **起源**：以太网最初由施乐公司（Xerox PARC）于1970年代开发，旨在连接办公室内的计算机。\n*   **标准化**：在1980年代，DEC、Intel和Xerox（DIX）共同发布了以太网规范。随后，电气和电子工程师协会（IEEE）将其标准化为 **IEEE 802.3** 系列标准，这使得以太网成为一个开放且被广泛接受的技术。\n\n#### 2. 核心特点与工作原理\n\n以太网在数据链路层使用**MAC地址**进行寻址，并在物理层定义了多种传输介质和信号编码方式。\n\n**a. MAC地址 (Media Access Control Address)**\n*   **作用**：每个以太网设备（如网卡）都有一个全球唯一的48位（6字节）物理地址，称为MAC地址。它用于在局域网中唯一标识设备，是数据链路层寻址的基础。\n*   **通俗举例**：MAC地址就像你家里的具体门牌号，在小区（局域网）内是唯一的。\n\n**b. 以太网帧 (Ethernet Frame)**\n*   **作用**：以太网将网络层的数据包封装成以太网帧进行传输。一个以太网帧包含：\n    *   **目的MAC地址**：接收方的MAC地址。\n    *   **源MAC地址**：发送方的MAC地址。\n    *   **类型/长度字段**：指示上层协议类型（如IP）或帧的数据长度。\n    *   **数据部分**：承载来自上层协议（如IP数据包）的实际数据。\n    *   **帧校验序列 (FCS)**：用于错误检测的校验码。\n*   **通俗举例**：以太网帧就像一个信封，上面写着收件人和发件人的门牌号（MAC地址），里面装着信件内容（数据），信封上还有个防伪码（FCS）来检查信件是否在传输过程中损坏。\n\n**c. 介质访问控制 (Media Access Control, MAC)**\n*   **CSMA/CD (载波侦听多路访问/冲突检测)**：\n    *   **原理**：在早期的共享介质（如集线器连接的总线型以太网）中，所有设备共享同一条传输介质。CSMA/CD机制规定，设备在发送数据前会先“侦听”介质上是否有其他设备正在发送。如果介质空闲，就发送数据；如果检测到冲突（多个设备同时发送），则会停止发送，等待随机时间后重试。\n    *   **局限性**：CSMA/CD只适用于半双工模式，且随着网络负载增加，冲突会增多，效率下降。\n*   **全双工与交换机**：\n    *   **现代以太网**：随着交换机（Switch）的普及，现代以太网主要工作在**全双工 (Full-Duplex)** 模式下。交换机为每个连接的设备提供独立的通信路径，使得设备可以同时发送和接收数据，从而消除了冲突，也就不再需要CSMA/CD。\n    *   **通俗举例**：CSMA/CD就像一条单行道，大家轮流过，如果两辆车同时进入就会撞车。而交换机就像一个多车道的立交桥，每辆车都有自己的专用车道，可以同时双向行驶，互不干扰。\n\n#### 3. 传输介质与速度演进\n\n以太网支持多种物理介质，并且随着技术发展，传输速度不断提升：\n\n*   **双绞线 (Twisted Pair)**：最常见的以太网线缆，如Cat5e、Cat6、Cat7等。\n    *   **10BASE-T**：10 Mbps (兆比特每秒)\n    *   **100BASE-TX (Fast Ethernet)**：100 Mbps\n    *   **1000BASE-T (Gigabit Ethernet)**：1 Gbps (千兆比特每秒)\n    *   **2.5GBASE-T, 5GBASE-T, 10GBASE-T**：2.5 Gbps, 5 Gbps, 10 Gbps\n*   **光纤 (Fiber Optic)**：用于长距离传输或需要更高带宽的场景。\n    *   **100BASE-FX (Fast Ethernet)**：100 Mbps\n    *   **1000BASE-SX/LX (Gigabit Ethernet)**：1 Gbps\n    *   **10GBASE-SR/LR (10 Gigabit Ethernet)**：10 Gbps\n    *   **40G Ethernet, 100G Ethernet, 400G Ethernet**：更高速度的光纤以太网标准，主要用于数据中心和骨干网络。\n\n#### 4. 优点\n\n*   **普及性**：作为最广泛使用的局域网技术，设备兼容性好，成本低。\n*   **可靠性**：通过错误检测机制确保数据传输的准确性。\n*   **灵活性**：支持多种传输介质和拓扑结构（星型、树型等）。\n*   **可扩展性**：从10Mbps到400Gbps甚至更高，能够满足不同规模和需求的网络。\n*   **易于管理**：相对成熟的技术，有丰富的管理工具和经验。\n\n总而言之，以太网是现代网络基础设施的基石，其标准化、高性能和灵活性使其成为连接各种设备的理想选择。","x":123,"y":900,"width":620,"height":280,"color":"2"},
		{"id":"ef711539c549dc42","type":"text","text":"### ARP (Address Resolution Protocol - 地址解析协议) 概述\n\n**ARP** 是一种网络层协议，它的主要作用是**将IP地址解析为物理MAC地址**。它是互联网协议（IP）和数据链路层（如以太网）之间进行通信的关键桥梁。\n\n#### 1. 为什么需要ARP？\n\n*   **IP地址**：用于在整个互联网上标识一台设备，是网络层寻址的逻辑地址。\n*   **MAC地址**：用于在局域网（LAN）中唯一标识一块网络接口卡（NIC），是数据链路层寻址的物理地址。\n\n当一台计算机（或路由器）需要向局域网内的另一台设备发送IP数据包时，它知道目的设备的IP地址，但数据链路层需要目的设备的MAC地址才能将数据封装成以太网帧并正确发送。ARP就是用来获取这个目的MAC地址的。\n\n#### 2. ARP的工作原理\n\nARP的工作流程主要通过**ARP请求**和**ARP响应**来完成：\n\n1.  **ARP请求 (ARP Request)**：\n    *   当一台主机（发送方）需要知道局域网内另一台主机（接收方）的MAC地址时，它会广播一个ARP请求包到整个局域网。\n    *   这个请求包中包含发送方的IP地址和MAC地址，以及它要查询的接收方的IP地址。\n    *   **通俗举例**：就像你在一个房间里大声喊：“请问，IP地址是‘192.168.1.10’的设备是谁？请告诉我你的‘门牌号’（MAC地址）！”\n\n2.  **ARP响应 (ARP Reply)**：\n    *   局域网内所有设备都会收到这个ARP请求。\n    *   只有拥有被查询IP地址的设备会响应这个请求。\n    *   该设备会发送一个ARP响应包，其中包含自己的MAC地址，并直接发送给请求方（单播）。\n    *   **通俗举例**：拥有‘192.168.1.10’的设备听到后，会直接走到你面前说：“我就是‘192.168.1.10’，我的‘门牌号’是‘AA:BB:CC:DD:EE:FF’。”\n\n3.  **ARP缓存 (ARP Cache)**：\n    *   为了避免每次通信都进行ARP请求，每台设备都会维护一个**ARP缓存表**。\n    *   这个表存储了最近解析过的IP地址与MAC地址的映射关系。当设备需要发送数据时，会首先查询ARP缓存表。如果找到对应的映射，就直接使用；如果没有，才会发送ARP请求。\n    *   缓存表中的条目通常有生命周期（TTL），过期后会被删除，需要重新解析。\n    *   **通俗举例**：你把刚才问到的“192.168.1.10”的“门牌号”记在你的小本本上（ARP缓存），下次再找它就不用再喊了，直接查小本本就行。\n\n#### 3. 总结\n\nARP是TCP/IP协议栈中一个看似简单但至关重要的协议。它有效地解决了IP地址（逻辑地址）与MAC地址（物理地址）之间的转换问题，使得数据包能够在局域网内正确地寻址和传输，是实现网络层与数据链路层互操作性的基础。","x":126,"y":640,"width":617,"height":220,"color":"2"},
		{"id":"3b6812c27c9ce163","type":"file","file":"Docs/数据链路层的主要工作方式.md","x":126,"y":380,"width":620,"height":220,"color":"2"},
		{"id":"df065993f3acbe17","type":"text","text":"ARP（地址解析协议）用于在局域网中将IP地址解析为MAC地址。当一台设备需要与另一台设备通信，但只知道对方的IP地址而不知道其MAC地址时，就会使用ARP。\n\n以下是一个具体的ARP工作流程例子：\n\n**场景：**\n假设在一个局域网中，计算机A（IP: 192.168.1.10, MAC: AA:AA:AA:AA:AA:AA）想要向计算机B（IP: 192.168.1.20, MAC: BB:BB:BB:BB:BB:BB）发送数据包。计算机A知道计算机B的IP地址，但不知道其MAC地址。\n\n**ARP工作流程：**\n\n1.  **检查ARP缓存：**\n    *   计算机A首先会检查自己的ARP缓存表。ARP缓存表存储了最近解析过的IP地址与MAC地址的对应关系。\n    *   在这个例子中，假设计算机A的ARP缓存中没有计算机B的MAC地址。\n\n2.  **发送ARP请求：**\n    *   由于缓存中没有找到，计算机A会生成一个ARP请求数据包。\n    *   这个ARP请求数据包包含以下信息：\n        *   **发送方IP地址：** 192.168.1.10 (计算机A的IP)\n        *   **发送方MAC地址：** AA:AA:AA:AA:AA:AA (计算机A的MAC)\n        *   **目标IP地址：** 192.168.1.20 (计算机B的IP)\n        *   **目标MAC地址：** 00:00:00:00:00:00 (或全F，表示未知，这是一个广播地址)\n    *   计算机A将这个ARP请求数据包封装在以太网帧中，并将以太网帧的目标MAC地址设置为广播地址（FF:FF:FF:FF:FF:FF）。\n    *   然后，计算机A将这个广播帧发送到局域网中。\n\n3.  **接收ARP请求：**\n    *   局域网中的所有设备都会接收到这个ARP广播帧。\n    *   每台设备都会解封装以太网帧，并检查其中的ARP请求数据包。\n\n4.  **处理ARP请求：**\n    *   每台设备会检查ARP请求中的“目标IP地址”是否与自己的IP地址匹配。\n    *   计算机C（IP: 192.168.1.30）会发现目标IP地址不是自己的，因此会丢弃这个ARP请求。\n    *   计算机B（IP: 192.168.1.20）会发现目标IP地址与自己的IP地址匹配。\n\n5.  **发送ARP响应：**\n    *   计算机B收到匹配的ARP请求后，会生成一个ARP响应数据包。\n    *   这个ARP响应数据包包含以下信息：\n        *   **发送方IP地址：** 192.168.1.20 (计算机B的IP)\n        *   **发送方MAC地址：** BB:BB:BB:BB:BB:BB (计算机B的MAC)\n        *   **目标IP地址：** 192.168.1.10 (计算机A的IP)\n        *   **目标MAC地址：** AA:AA:AA:AA:AA:AA (计算机A的MAC)\n    *   计算机B将这个ARP响应数据包封装在以太网帧中，并将以太网帧的目标MAC地址设置为计算机A的MAC地址（AA:AA:AA:AA:AA:AA）。这是一个单播帧。\n    *   然后，计算机B将这个单播帧发送回局域网。\n\n6.  **接收ARP响应并更新缓存：**\n    *   计算机A接收到来自计算机B的ARP响应。\n    *   计算机A会从ARP响应中提取计算机B的MAC地址（BB:BB:BB:BB:BB:BB）。\n    *   计算机A将IP地址192.168.1.20与MAC地址BB:BB:BB:BB:BB:BB的对应关系添加到自己的ARP缓存表中。\n\n7.  **数据通信：**\n    *   现在，计算机A已经知道了计算机B的MAC地址。\n    *   计算机A可以将原始数据包封装在以太网帧中，并将目标MAC地址设置为BB:BB:BB:BB:BB:BB，然后发送给计算机B。\n    *   后续计算机A与计算机B之间的通信可以直接使用缓存中的MAC地址，直到ARP缓存条目过期或被清除。\n\n通过这个过程，计算机A成功地解析了计算机B的IP地址对应的MAC地址，从而可以在局域网中进行直接的数据通信。","x":800,"y":640,"width":715,"height":220,"color":"2"},
		{"id":"49ae4ceca94efc32","type":"text","text":"ICMP (Internet Control Message Protocol) 是一种在IP网络设备之间传递**控制消息和错误报告**的协议。它不是用来传输用户数据的，而是作为IP协议的**辅助协议**，用于诊断网络问题、报告错误以及提供网络状态信息。\n\n### ICMP 协议概述：\n\n*   **位置：** ICMP 协议工作在 OSI 模型的**网络层**，与 IP 协议紧密结合。虽然它有自己的协议号（IPv4中为1），但它实际上是封装在 IP 数据包中的。\n*   **目的：** 弥补 IP 协议“无连接、不可靠”的特性。IP 协议只负责尽力而为地转发数据包，不提供错误检测和报告机制。ICMP 填补了这一空白，允许网络设备（如路由器和主机）在数据包传输过程中遇到问题时进行通信。\n*   **主要功能：**\n    1.  **错误报告：** 当 IP 数据包在传输过程中遇到问题（如目标不可达、TTL超时、参数错误等）时，ICMP 消息会通知源主机。\n    2.  **查询功能：** 允许主机或路由器查询其他网络设备的信息，例如 `ping` 命令就是利用 ICMP 的回显请求/应答功能来测试网络连通性。\n\n### ICMP 协议工作流程的具体例子：`ping` 命令\n\n`ping` 命令是使用 ICMP 协议最常见的例子，它用于测试两台主机之间的网络连通性。\n\n**场景：**\n假设您的计算机（源主机，IP: 192.168.1.10）想要测试与一个远程服务器（目标主机，IP: 203.0.113.50）的连通性。\n\n**ICMP `ping` 工作流程：**\n\n1.  **用户执行 `ping` 命令：**\n    您在命令行输入 `ping 203.0.113.50`。\n\n2.  **源主机生成 ICMP Echo Request (回显请求)：**\n    *   您的操作系统（或 `ping` 程序）会创建一个 **ICMP Echo Request 消息**。\n    *   这个消息包含一个标识符（通常是进程ID）和一个序列号，以及可选的数据载荷（通常是一些填充字节）。\n    *   ICMP Echo Request 消息被封装在一个 **IP 数据包**中。\n        *   IP 头部的源 IP 地址是 `192.168.1.10`。\n        *   IP 头部的目标 IP 地址是 `203.0.113.50`。\n        *   IP 头部的协议字段会设置为 `1`，表示数据载荷是 ICMP 协议。\n    *   这个 IP 数据包随后被发送到网络中。\n\n3.  **IP 数据包路由：**\n    *   IP 数据包从您的计算机发出，经过您的本地路由器，然后通过互联网上的多个路由器，最终向目标 IP 地址 `203.0.113.50` 传输。\n    *   每个路由器在转发数据包时，会检查 IP 头部的目标 IP 地址，并根据其路由表决定下一个跳（next hop）。\n\n4.  **目标主机接收 ICMP Echo Request：**\n    *   当 IP 数据包到达目标服务器 `203.0.113.50` 时，服务器的操作系统会解封装 IP 数据包。\n    *   它发现 IP 协议字段是 `1`，表明这是一个 ICMP 消息。\n    *   它进一步识别出这是一个 ICMP Echo Request 消息。\n\n5.  **目标主机生成 ICMP Echo Reply (回显应答)：**\n    *   目标服务器收到 Echo Request 后，会立即生成一个 **ICMP Echo Reply 消息**。\n    *   这个 Reply 消息会复制 Echo Request 中的标识符和序列号，并将数据载荷原样返回。\n    *   ICMP Echo Reply 消息同样被封装在一个 **IP 数据包**中。\n        *   IP 头部的源 IP 地址是 `203.0.113.50`。\n        *   IP 头部的目标 IP 地址是 `192.168.1.10`。\n        *   IP 头部的协议字段仍然是 `1`。\n    *   这个 IP 数据包随后被发送回网络。\n\n6.  **IP 数据包路由返回：**\n    *   ICMP Echo Reply 数据包沿着与去程相似（但不一定完全相同）的路径，通过互联网上的路由器，最终返回到您的计算机。\n\n7.  **源主机接收 ICMP Echo Reply：**\n    *   您的计算机接收到来自 `203.0.113.50` 的 IP 数据包，并识别出其中的 ICMP Echo Reply 消息。\n    *   `ping` 程序会匹配这个 Reply 消息与之前发送的 Request 消息（通过标识符和序列号）。\n\n8.  **`ping` 命令输出结果：**\n    *   `ping` 程序计算从发送 Echo Request 到接收 Echo Reply 所花费的时间（往返时间 RTT）。\n    *   它会在命令行显示类似以下的信息：\n        ```\n        Reply from 203.0.113.50: bytes=32 time=50ms TTL=55\n        Reply from 203.0.113.50: bytes=32 time=48ms TTL=55\n        ...\n        ```\n    *   如果目标不可达或数据包丢失，您可能会看到“Request timed out”（请求超时）或“Destination Host Unreachable”（目标主机不可达）等错误消息，这些错误消息本身也可能是由其他 ICMP 消息（如“目标不可达”ICMP 消息）触发的。\n\n通过这个 `ping` 过程，ICMP 协议允许您快速诊断网络连通性，了解数据包是否能够到达目标，以及往返所需的时间。","x":123,"y":-50,"width":623,"height":360,"color":"5"},
		{"id":"b04522bde214e686","type":"file","file":"Docs/IP协议详解 (Internet Protocol).md","x":800,"y":-50,"width":740,"height":630,"color":"5"},
		{"id":"e99b7b0af5b29d58","type":"file","file":"Docs/UDP 协议详解.md","x":126,"y":-490,"width":620,"height":380,"color":"6"},
		{"id":"8418a07c8d21777e","type":"file","file":"Docs/UDP-Lite 协议.md","x":845,"y":-415,"width":695,"height":305,"color":"6"},
		{"id":"7a7c3b2b3179896c","type":"file","file":"Docs/TCP协议详解.md","x":118,"y":-930,"width":682,"height":310,"color":"6"},
		{
			"id":"55384b1b5e79aa2a",
			"type":"text",
			"text":"## 在TCP建立完链接以后，假设客户端在握手阶段创建的seq是2000,那是否在后续发送流数据的时候，每次都会在此基础上加1？每次发送的数据大小有限制吗？\n\n非常好的问题！我们用最清晰的方式一次性说透这两个核心点。\n\n### 1. 序列号（Seq）是不是每次发送都只加 1？\n\n**不是加 1，而是加「本次发送的字节数」！**\n\n- 握手结束后，客户端的初始序列号是 2000（即第三次握手 ACK 的 seq = 2001，但第一个数据字节从 2001 开始算）。\n- 之后每发送一个数据段，Seq = **上一次已发送的最后一个字节的下一个编号**。\n- 也就是说：**序列号是按实际发送的字节数累加的，而不是按包数加 1、1、1 地加**。\n\n举个真实例子（假设客户端要发送一句话 \"HelloTCPWorld\"，共 13 字节）：\n\n| 次数 | 发送内容           | 本次发送字节数 | 本次报文的 Seq 值 | 发送后下一个可用 Seq |\n|------|--------------------|----------------|-------------------|----------------------|\n| 握手 | 第三次握手 ACK     | 0 字节         | 2001              | 2001                 |\n| 1    | \"Hello\"            | 5 字节         | 2001              | 2006                 |\n| 2    | \"TCP\"              | 3 字节         | 2006              | 2009                 |\n| 3    | \"World\"            | 6 字节         | 2009              | 2015                 |\n\nWireshark 里你会看到三个包的 Seq 分别是：\n```\nSeq=2001  Len=5   → 包含 \"Hello\"\nSeq=2006  Len=3   → 包含 \"TCP\"\nSeq=2009  Len=6   → 包含 \"World\"\n```\n\n**记住公式**：  \n**本次报文的 Seq = 上次已发送的最后一个字节号 + 1**  \n**下次可用 Seq = 本次 Seq + 本次数据长度（不含 SYN/FIN）**\n\n> SYN 和 FIN 也各消耗 1 个序列号，但普通数据段只按实际 payload 字节数消耗。\n\n### 2. 每次发送的数据大小有限制吗？\n\n**有！而且有好几层限制，取最小值**\n\n| 限制来源                 | 最大值（典型值）         | 说明                                                                 |\n|--------------------------|--------------------------|----------------------------------------------------------------------|\n| ① 链路层 MTU             | 1500 字节（以太网最常见）| 以太网标准 MTU=1500，减去 IP 头 20 + TCP 头 20 ≈ 1460 字节有效载荷 |\n| ② TCP MSS（握手时协商）  | 通常 1460 字节           | 双方在 SYN 包里用 MSS 选项协商，绝不会超过 MTU-40                   |\n| ③ 接收方通告窗口（rwnd） | 取决于对方当前窗口大小   | 比如对方窗口只剩 8000 字节，你最多一次发 8000 字节                   |\n| ④ 拥塞窗口（cwnd）       | 由拥塞控制算法决定       | 慢启动时可能只有几 KB，高速网络可达几 MB                            |\n| ⑤ Nagle 算法 / 延迟 ACK   | 可能强制小包合并         | 避免傻瓜式发送 1 字节 1 包                                             |\n\n**实际中一个 TCP 报文最多能带的数据（Payload）**：\n- 普通以太网：**1460 字节**（最常见）\n- 开启 Jumbo Frame（9000 MTU）：可达 **8960 字节**\n-  所以你平时用 Wireshark 看网页、下载文件，看到的 TCP Segment Len 大多是 1448、1460 这几个值。\n\n### 总结一句话记法\n\n| 问题                         | 答案                                      |\n|------------------------------|-------------------------------------------|\n| 序列号是不是每次 +1？         | 错！是 + 本次发送的字节数                 |\n| 每次最多能发多少数据？       | 通常 1460 字节，受 MSS、窗口、MTU 多重限制 |\n\n掌握了这两点，你就能看懂 Wireshark 里为什么 Seq 是跳着长的（2001 → 3461 → 6381…），而不是傻傻地 2001、2002、2003…了。\n\n![[mermaid-diagram (1).svg]]",
			"styleAttributes":{},
			"x":1880,
			"y":-1720,
			"width":800,
			"height":360,
			"color":"2"
		},
		{
			"id":"ff40b55e06644573",
			"type":"text",
			"text":"## TCP在建立链接以后，每次发送数据段必须要等服务端返回ACK消息吗？\n**不是！**  \nTCP 建立连接后，**发送数据段根本不需要“每次”都等对方 ACK 才能发下一个**。  \n这正是 TCP 能跑出高带宽的根本原因。\n\n用一句话概括：\n\n> **TCP 是“滑动窗口”协议”，一次可以连续发送多个数据段，只要不超过当前允许的窗口，就可以不等 ACK 就继续发。**\n\n### 真实工作方式对比（超清楚）\n\n| 误解的“傻瓜式”TCP（不存在）       | 真实的 TCP（滑动窗口）                        |\n|------------------------------------|-----------------------------------------------|\n| 发一个段 → 等 ACK → 再发一个段 → 等 ACK … | 发一批段 → 对方边收边回 ACK → 我继续滑窗口往前发 |\n| 1 个 RTT 只能传 1 个段，速度极慢   | 1 个 RTT 可以传几十甚至几百个段，跑满带宽     |\n\n### 举一个实际数字例子（假设 MSS=1460 字节）\n\n| 时刻               | 客户端已发送但未确认的字节 | 当前允许发送的窗口（对方通告） | 还能继续发多少个段 |\n|--------------------|----------------------------|--------------------------------|--------------------|\n| 刚建好连接         | 0                          | 64 KB（65535 字节）            | 还能连发 44 个段   |\n| 连发 20 个段       | 29200 字节                 | 64 KB                          | 还能再发 24 个     |\n| 收到一个 ACK       | 降到 14600 字节            | 64 KB                          | 窗口向前滑动，又能发更多 |\n| …                  | …                          | …                              | …                  |\n\n只要 **已发送但未确认的字节数 < 接收方通告的窗口（rwnd） 和 拥塞窗口（cwnd） 的最小值**，  \n客户端就可以**不停地发包，完全不用等 ACK**。\n\n### Wireshark 里你会看到的真实画面（访问大文件时）\n\n```\n客户端 → 服务器   Seq=1    Len=1460\n客户端 → 服务器   Seq1461  Len=1460\n客户端 → 服务器   Seq2921  Len=1460\n客户端 → 服务器   Seq4381  Len=1460\n...连续发了 30 个段...\n服务器 → 客户端             ACK=43810   ← 一次性确认前面 30 个段\n客户端 → 服务器   Seq43810  Len=1460   ← 窗口滑动，继续狂发\n```\n\n这就是为什么下载大文件时，TCP 速度能跑到几百 Mbps 甚至 Gbps —— 它根本不是一问一答，而是“火车皮”一样一长串发出去。\n\n### 什么时候才真的会“停下来等 ACK”？\n\n只有以下几种情况会暂停发送：\n\n1. **接收方窗口用完**（对方回的 ACK 中 window=0 或很小）\n2. **拥塞窗口用完**（网络丢包导致 cwnd 缩小）\n3. **Nagle 算法故意延迟小包**（和延迟 ACK 配合，避免傻瓜式发 1 字节包）\n\n正常高带宽场景下，这三种情况都很少触发，所以你看到的就是“连发一大堆 → 收到一个累计 ACK → 再连发一大堆”。\n\n### 总结一句话\n\n**TCP 建立连接后，发送数据段完全不需要每次都等 ACK，  \n它靠滑动窗口一次可以连发几十甚至几百个段，只有窗口耗尽才会停下来等 ACK。**\n\n这就是 TCP 能跑满千兆/万兆网卡的秘密！",
			"styleAttributes":{},
			"x":1880,
			"y":-1340,
			"width":800,
			"height":280,
			"color":"2"
		},
		{"id":"d1d428008481a3a9","type":"file","file":"Docs/HTTP 协议详细介绍.md","x":-660,"y":-1420,"width":692,"height":400},
		{"id":"ac203ff2f015cfa5","type":"file","file":"Docs/TCP 复用TCP 复用.md","x":-160,"y":-1860,"width":692,"height":400},
		{"id":"001b654866c849e8","type":"file","file":"Docs/HTTP-3 与 QUIC 协议详细介绍.md","x":-1000,"y":-1920,"width":800,"height":380},
		{"id":"d594b1257902dadc","type":"file","file":"Docs/详述 Socket 协议.md","x":-1994,"y":-930,"width":800,"height":480},
		{
			"id":"3ab676352610623c",
			"type":"text",
			"text":"\n## 🧐 什么是长连接？\n\n长连接指的是在客户端和服务器之间建立一次连接后，**这个连接会保持开启状态，不会立即关闭**。在连接保持期间，客户端和服务器可以利用这同一个连接**反复发送和接收数据**，直到一方主动关闭连接或连接因超时而断开。\n\n### 📌 **对比短连接**\n\n| 特性 | 长连接 (Persistent Connection) | 短连接 (Non-persistent Connection) |\n| :--- | :--- | :--- |\n| **连接建立** | 只需进行一次 **TCP 三次握手** | 每次通信都需要进行 **TCP 三次握手** |\n| **数据传输** | 可以在建立的连接上多次传输数据 | 每次传输数据后立即进行 **TCP 四次挥手** 关闭连接 |\n| **资源消耗** | 节省了多次建立/关闭连接的开销，**效率更高** | 每次通信都增加握手和挥手开销，**资源消耗较大** |\n| **适用场景** | 频繁的客户端-服务器通信，如**即时通讯**、**实时数据推送**、**数据库连接池** | 低频率、请求-响应式的简单通信，如早期的简单 **HTTP 网页浏览** |\n\n在 **TCP 协议**中，长连接省去了多次建立和关闭连接的操作，**减少了延迟并节约了时间**。\n\n---\n\n## 🛠️ 长连接的实现手段\n\n长连接的实现可以基于不同的协议和技术，以下是一些主要的实现方式：\n\n### 1. **基于 HTTP 协议的长连接**\n\n虽然 HTTP 本身是无状态的请求-响应协议，但通过一些机制可以实现连接的保持：\n\n* **HTTP/1.1 `Keep-Alive`**\n    * 在 HTTP/1.1 协议中，默认支持连接保持（Keep-Alive）。\n    * 客户端在请求头中发送 `Connection: keep-alive`，服务器如果在响应头中也包含此字段，则连接在完成本次请求响应后**不会立即关闭**，而是等待客户端的下一个请求。\n    * 通常会有一个**超时时间**（例如几秒到几十秒），如果在超时时间内没有新的请求，连接才会被关闭。\n* **HTTP/2 和 HTTP/3**\n    * 这两种协议在设计上对长连接和多路复用有更好的支持。它们允许在一个连接上**同时发送多个独立的请求和响应**，极大地提高了效率和性能。\n\n### 2. **基于 WebSocket 协议**\n\nWebSocket 是一种**应用层协议**，它在单个 TCP 连接上提供**全双工通信**通道。\n\n* **实现原理：** 客户端通过一个 **HTTP 握手**（通常是升级请求 `Upgrade: websocket`）来建立连接。握手成功后，该 TCP 连接将从 HTTP 协议升级到 WebSocket 协议。\n* **特点：** 一旦连接建立，服务器和客户端可以**互相主动推送数据**，非常适合需要**服务器实时推送**数据的应用，如即时聊天、实时股票行情、多人游戏等。\n* **优势：** 相比传统的 HTTP 长轮询，WebSocket 避免了重复的 HTTP 头开销，**效率更高，延迟更低**。\n\n### 3. **基于 TCP Socket 的自定义协议**\n\n对于性能要求极高或需要完全控制通信的应用（如金融交易系统、游戏服务器），开发者可以直接基于 **TCP/IP 协议**，使用 **Socket 编程**来实现自定义的长连接机制。\n\n* **实现原理：** 客户端和服务器直接通过 TCP Sockets 建立连接。连接的保持、数据的编解码、心跳机制、断线重连等全部由应用层自行管理。\n* **心跳机制：** 为了防止连接因长时间没有数据传输而被网络设备（如防火墙、路由器）或系统内核关闭，应用层通常会设计**心跳包**（Heartbeat）。客户端或服务器会定期发送很小的**保活数据包**来维持连接的活跃状态。\n\n### 4. **长轮询 (Long Polling)**\n\n虽然长轮询**并非真正的长连接**（它本质上仍然是请求-响应模式），但在没有 WebSocket 或其他长连接技术时，它常被用来**模拟服务器推送**的效果。\n\n* **实现原理：** 客户端发送一个 HTTP 请求给服务器，服务器**不立即响应**，而是阻塞该请求。直到服务器有新的数据需要发送，或者达到预设的超时时间，服务器才返回响应并关闭连接。客户端收到响应后，会**立即发起下一个请求**，从而形成“轮询”的效果。\n\n---\n\n## 💡 总结与建议\n\n* 如果您需要**服务器实时、主动推送**数据，**WebSocket** 是目前最推荐的实现方式。\n* 如果您只是想**节省 HTTP 请求的连接开销**，`Keep-Alive` 或 **HTTP/2/3** 已经足够。\n* 如果您在追求极致的性能和自定义控制，可以考虑基于 **TCP Socket 的自定义协议** + **心跳机制**。\n\n您目前正在开发什么类型的应用？我可以帮您分析哪种长连接实现方式最适合您的场景。",
			"styleAttributes":{
				"textAlign":null
			},
			"x":-2880,
			"y":-870,
			"width":750,
			"height":360
		},
		{"id":"c1ed247f3cbbdc6c","type":"file","file":"Docs/QA-Socket.md","x":-1994,"y":-360,"width":800,"height":400},
		{"id":"f9b27144d83820c0","type":"file","file":"握手和挥手阶段的消息如果发送失败了会怎样？.md","x":940,"y":-1800,"width":670,"height":340},
		{
			"id":"166d74726f577eaf",
			"type":"file",
			"file":"Docs/UDP相比IP协议，除了增加端口号用来实现多路复用，还有那些区别呢？.md",
			"styleAttributes":{
				"border":null
			},
			"x":858,
			"y":-740,
			"width":682,
			"height":280,
			"color":"6"
		},
		{"id":"683596532083cd3e","type":"file","file":"TCP 中 server 的 ACK 是如何计算的？.md","x":1880,"y":-1040,"width":800,"height":300},
		{"id":"1327b1c744b83e02","type":"file","file":"Canvas/一个真实的网络请求流程.canvas","x":-1640,"y":340,"width":400,"height":400}
	],
	"edges":[
		{"id":"c118c2b7a27d8f6c","toFloating":false,"fromNode":"3d196d0cfa64859c","fromSide":"right","toNode":"3e5ae91a55a88bd2","toSide":"left"},
		{"id":"c4552abb026610f9","fromNode":"3d196d0cfa64859c","fromSide":"right","toNode":"8ab9973a1783d912","toSide":"left"},
		{"id":"db47b1db9602ab9b","fromNode":"3d196d0cfa64859c","fromSide":"right","toNode":"a0635267dee089ee","toSide":"left"},
		{"id":"6d08fcb2d45dedea","fromNode":"3d196d0cfa64859c","fromSide":"right","toNode":"518713a596b3cbff","toSide":"left"},
		{"id":"d7dc4f5ed0d74e79","fromNode":"3d196d0cfa64859c","fromSide":"right","toNode":"82e2829fe918b467","toSide":"left"},
		{"id":"126f2560af77bf5b","fromNode":"518713a596b3cbff","fromSide":"right","toNode":"3b6812c27c9ce163","toSide":"left"},
		{"id":"df888cf51f5a2079","fromNode":"518713a596b3cbff","fromSide":"right","toNode":"1b7efd5a34e7ccb0","toSide":"left"},
		{"id":"712a61c62071aa25","fromNode":"b9bdb30c217fe544","fromSide":"bottom","toNode":"2ee1d7063c316a59","toSide":"top"},
		{"id":"5da512cba3322bc8","toFloating":false,"fromNode":"b9bdb30c217fe544","fromSide":"right","toNode":"932d4850b6ed05ec","toSide":"top"},
		{"id":"a16c07852d259cc3","fromNode":"518713a596b3cbff","fromSide":"right","toNode":"ef711539c549dc42","toSide":"left"},
		{"id":"2e279a97190d0a83","fromNode":"ef711539c549dc42","fromSide":"right","toNode":"df065993f3acbe17","toSide":"left"},
		{"id":"6f39de912f30e62f","fromNode":"a0635267dee089ee","fromSide":"right","toNode":"49ae4ceca94efc32","toSide":"left"},
		{"id":"995417a24eece738","fromNode":"a0635267dee089ee","fromSide":"right","toNode":"b04522bde214e686","toSide":"left"},
		{"id":"f2f5bd6c13fc9106","fromNode":"8ab9973a1783d912","fromSide":"right","toNode":"e99b7b0af5b29d58","toSide":"left"},
		{"id":"a38816e7b791a9c6","fromNode":"e99b7b0af5b29d58","fromSide":"right","toNode":"8418a07c8d21777e","toSide":"left"},
		{"id":"c6c1a6712205e595","fromNode":"e99b7b0af5b29d58","fromSide":"right","toNode":"166d74726f577eaf","toSide":"left"},
		{
			"id":"3b9514a6a1d75b60",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"8ab9973a1783d912",
			"fromSide":"right",
			"toNode":"7a7c3b2b3179896c",
			"toSide":"left"
		},
		{
			"id":"c51700653587840f",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"7a7c3b2b3179896c",
			"fromSide":"top",
			"toNode":"c38718bfa297e09c",
			"toSide":"left"
		},
		{
			"id":"7474df0f9bea358f",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"7a7c3b2b3179896c",
			"fromSide":"top",
			"toNode":"b6bb4b9dfcd00acd",
			"toSide":"left"
		},
		{
			"id":"8d055f40a8e41d63",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"c38718bfa297e09c",
			"fromSide":"right",
			"toNode":"55384b1b5e79aa2a",
			"toSide":"left"
		},
		{
			"id":"5136ae858bee83eb",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"c38718bfa297e09c",
			"fromSide":"right",
			"toNode":"ff40b55e06644573",
			"toSide":"left"
		},
		{
			"id":"9b7ae1dc229faa64",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"c38718bfa297e09c",
			"fromSide":"right",
			"toNode":"683596532083cd3e",
			"toSide":"left"
		},
		{
			"id":"6bbd8c56245a5eab",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"7a7c3b2b3179896c",
			"fromSide":"top",
			"toNode":"f9b27144d83820c0",
			"toSide":"left"
		},
		{
			"id":"9e85fcbbc939e984",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"3ab676352610623c",
			"fromSide":"right",
			"toNode":"d594b1257902dadc",
			"toSide":"left"
		},
		{
			"id":"690f3d9911c08b2c",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"d594b1257902dadc",
			"fromSide":"right",
			"toNode":"8ab9973a1783d912",
			"toSide":"left"
		},
		{
			"id":"7b708dbdd9a72ccc",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"d1d428008481a3a9",
			"fromSide":"left",
			"toNode":"d00e8a1bef0cefb6",
			"toSide":"right"
		},
		{
			"id":"46049c8e2c154503",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"7a7c3b2b3179896c",
			"fromSide":"top",
			"toNode":"ac203ff2f015cfa5",
			"toSide":"right"
		},
		{
			"id":"833ee56fdaadd5a9",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"d1d428008481a3a9",
			"fromSide":"right",
			"toNode":"ac203ff2f015cfa5",
			"toSide":"bottom"
		},
		{
			"id":"b989a5d1aca1dce1",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"d1d428008481a3a9",
			"fromSide":"top",
			"toNode":"001b654866c849e8",
			"toSide":"bottom"
		},
		{
			"id":"81faf9169075adfc",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"3e5ae91a55a88bd2",
			"fromSide":"top",
			"toNode":"d1d428008481a3a9",
			"toSide":"bottom"
		},
		{
			"id":"a698d00a6f9c2816",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"d594b1257902dadc",
			"fromSide":"bottom",
			"toNode":"c1ed247f3cbbdc6c",
			"toSide":"top"
		},
		{
			"id":"32927e8e6dc627a8",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"49ae4ceca94efc32",
			"fromSide":"left",
			"toNode":"b9bdb30c217fe544",
			"toSide":"top"
		},
		{
			"id":"f88b793884ebe0fc",
			"styleAttributes":{},
			"toFloating":false,
			"fromNode":"3d196d0cfa64859c",
			"fromSide":"bottom",
			"toNode":"1327b1c744b83e02",
			"toSide":"top"
		}
	],
	"metadata":{
		"version":"1.0-1.0",
		"frontmatter":{},
		"startNode":"8044c4f908e89939"
	}
}