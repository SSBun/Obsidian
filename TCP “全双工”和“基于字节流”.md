

### 1. 全双工（Full-Duplex）  
意思是：**通信双方可以同时向对方发送和接收数据，互不干扰**。

| 比喻             | 说明                                                                 |
|------------------|----------------------------------------------------------------------|
| 生活例子         | 两个人用两部电话机打电话，你说我也说，同时进行，不需要轮流按“对讲机”按钮 |
| 半双工（对比）   | 对讲机：你讲的时候我不能讲，我讲的时候你不能讲（比如 UDP 某些场景、走私对讲） |
| 单工（对比）     | 广播电台：只能我讲你们听，你们不能回话                                 |

在 TCP 里体现为：
- 客户端 → 服务器 和 服务器 → 客户端 各维护一套独立的序列号（Seq）和确认号（Ack）
- 双方都可以随时发送数据段，哪怕上一个方向的数据还没确认完
- Wireshark 里你会看到上下行数据交叉出现，而不是严格你一句我一句

抓包例子（访问网页时）：
```
客户端 → 服务器：Seq=1001  (发送 HTTP GET 请求)
服务器 → 同时 → 客户端：Seq=5001  (开始推回 HTML 数据)
客户端 → 服务器：Seq=1500  (继续发 ACK 或下一个请求)
服务器 → 客户端：Seq=8000  (继续推数据)
```
两条“车道”完全独立，互不堵塞，这才是真正的全双工。

### 2. 基于字节流（Byte Stream）  
意思是：**TCP 把应用层交给它的数据当成一串连续的、无结构的字节流来传输，没有任何“消息边界”概念**。

| 对比协议       | 有无消息边界 | 例子                                                                 |
|----------------|--------------|----------------------------------------------------------------------|
| TCP            | 无           | 字节流，连续的水管                                                   |
| UDP            | 有           | 报文（datagram），一个个信封                                         |
| HTTP/1.1 无分块| 需要应用层自己解决边界 | 靠 Content-Length 或分块编码                                         |
| gRPC、WebSocket| 应用层再包装 | 在字节流上自己定义帧边界                                             |

生活例子对比：

| 场景               | UDP（有边界）像这样                                 | TCP（字节流）像这样                                 |
|--------------------|-----------------------------------------------------|-----------------------------------------------------|
| 你发三句话给朋友   | 发 3 个独立微信消息，每条都能单独显示               | 把三句话连起来发成一条超长消息，接收方不知道哪里断句 |
| 写文件             | 发 3 个独立文件块，接收端知道正好是 3 3 块         | 把整个文件倒进水管，接收端只看到一长串字节           |

真实代码例子：

```python
# 客户端连发三次 send（每次 1000 字节）
socket.send(b"A" * 1000)
socket.send(b"B" * 1000)
socket.send(b"C" * 1000)

# 服务器端可能这样收（完全合法！）
data1 = socket.recv(4096)   # 一次性收到 "AAA...BBB..." 2000+ 字节
data2 = socket.recv(4096)   # 再收到剩下的
```

服务器根本不知道你分了 3 次 send，它只看到 3000 个连续的字节。

这就是“基于字节流”的威力与陷阱：
- 威力：实现简单、效率高、适合大文件、流媒体
- 陷阱：应用层必须自己解决“哪里是一条完整消息”的问题（常见方案：长度前缀、分隔符、协议缓冲等）

### 总结一句话记法

| 属性     | 一句话记住                                   | 关键后果                             |
|----------|----------------------------------------------|--------------------------------------|
| 全双工   | 两条水管，两个方向同时喷水，互不干扰         | 可以同时上传下载、同时发请求和响应   |
| 字节流   | 把数据倒进水管，接收端只看到一整条水流       | 没有消息边界，应用层要自己粘包/拆包 |

理解了这两点，你就真正理解了为什么：
- TCP 连接可以一边上传一边下载
- 为什么有时候 recv 一次收到多条“消息”
- 为什么 HTTP/2、gRPC 都要在 TCP 之上再定义一层的“帧”

这就是 TCP 之所以强大、也“难用”的根本原因！